#include "sdf.h"
#include "tool.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <pthread.h>
#include <sys/time.h>
#include <time.h>

int sdf_opentest() {
    void *hDeviceHandle = NULL;
    int ret = -1;
    ret = SDF_OpenDevice((void **) &hDeviceHandle);
    printf("SDF_OpenDevice, ret=0x%08x\n", ret);
    if (SDR_OK != ret || hDeviceHandle == NULL) {
        printf("SDF_OpenDevice error=%d\n", ret);
        return -1;
    }
    //printf("hfile=%d\n",((SOFT_DEVICE *)hDeviceHandle)->hFile);
    //printf("szFilePath=%s \n",((SOFT_DEVICE *)hDeviceHandle)->szFilePath);
    return 0;
}

#define SUPPORT_IMPORT_KEY 1


int WriteCaCert(void *hSessionHandle) {
    int ret;
    int bits;
    int i, j;
    unsigned int uiKeyIndex = 6;
    RSArefPublicKey publicKey = {0};
    RSArefPrivateKey privateKey = {0};
    RSArefPublicKey signPublicKey = {0};
    RSArefPublicKey encPublicKey = {0};
    unsigned char datain[2 * 1024] = {0};
    unsigned char dataout[2 * 1024] = {0};
    unsigned char verify[2 * 1024] = {0};
    unsigned char datain1[2 * 1024] = {0};
    char *password = "soft1234";
    unsigned int pswlen = 0;
    unsigned int inlen = 0;
    unsigned int outlen = 0;
    unsigned int verifylen = 0;

    for (i = 0; i < 2; i++) {
        if (0 == i) {
            bits = 1024;
        } else {
            bits = 2048;
            uiKeyIndex += 1;
        }

        ret = SDF_GenerateKeyPair_RSA(hSessionHandle, bits, &publicKey, &privateKey);
        printf("SDF_GenerateKeyPair_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_GenerateKeyPair_RSA\n");
            goto EXIT;
        }
#if 1
        if (0 == i)
        {
             memcpy((unsigned char *)&publicKey,
                    "\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xbb\x1f\x9a\x00\x65\x91\x31\x47\xc2\xae\xfb\x3c\xe7\xce\x82\xe0\xc2\xf0\x0a\x47\xbb\xca\xa3\xcf\x90\x75\x67\x16\x7e\xb8\x33\xa3\x39\x10\x0a\x13\xb2\x46\x3c\x2b\x85\x35\x68\x64\x86\x45\x99\x68\xca\xe4\x7b\x79\x3e\x16\x71\xa7\x81\x9d\x65\x72\x42\x15\xc1\xa4\x2a\xbf\xf5\xf4\x95\x93\x87\xe4\x6f\x7e\x75\xc1\x0e\xf7\xbd\x37\x8b\x1a\xab\x4a\x00\x2c\x6a\x07\x5b\x5c\x3a\x5c\xe2\x02\xa6\x3c\x56\xcc\xca\x68\xd8\x6e\xbc\xd9\xd2\xa4\x12\x92\x03\x2a\x29\x37\xb2\xfb\x5b\xfe\xe8\x57\xaa\x05\xa7\x44\x94\xe1\xe6\xaf\xcd\xfb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x01",
                    sizeof(RSArefPublicKey));
             memcpy((unsigned char *)&privateKey,
                    "\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x71\x4f\xae\x17\x4c\x7b\x76\x45\x3b\xd1\xd6\x55\xd6\xaf\x08\x0c\xda\x72\x0f\xe6\x42\x91\x4b\xa8\x6a\x66\x48\x3e\xf7\xdd\x00\xb7\x64\x28\xb4\x43\xcf\x20\x65\xb4\x88\x82\x1d\x2c\x88\xc7\x9e\x69\x51\x6a\x9c\x84\x9f\x62\x20\xd7\xe8\x86\xc9\x64\xac\xed\x74\xaf\x59\x68\x0c\x0f\xa7\xfe\x8f\xda\x05\x80\x24\x94\xa1\x16\x05\x95\x11\xe4\x06\x94\xf4\xf4\x20\xe8\x06\xb4\x23\x40\x32\x3d\x89\x64\xc6\xfa\xfa\x67\x15\xc9\x8b\x52\x58\x35\xd4\x7b\xe3\xc8\x32\xdf\xab\x85\xce\x64\x66\xc9\x20\xbd\x53\xf9\x87\x3d\x57\x7c\xa1\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe1\xb0\x0e\x40\x77\xbd\xfb\x93\x8b\xad\x86\x1c\x59\x8a\x31\xdf\xe7\xf7\xc4\x08\x04\x6d\xf1\x92\x29\x89\x82\x59\xc8\x3d\xcc\x73\xe1\xcd\xce\x29\xcf\xcf\xa8\x7a\x46\x2b\x8d\xca\x20\x23\x85\x8e\x1f\xcc\x5b\xb4\x68\x4a\x6c\x7c\x7f\xb0\x05\xfa\x4d\xa3\xf5\x09\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd4\x41\x91\xc1\x98\x43\xae\x63\xfb\xea\x3a\x5d\xe6\x6e\x66\x21\xa2\x76\x36\x7d\xb3\xa8\x0b\xa3\xb8\x42\x3c\x7e\x2f\x81\xc6\x35\xc5\xba\x46\x7a\x7d\x83\xd3\xe9\xa2\x29\xb5\x85\xe0\x6f\xd4\x1c\x2e\x52\x59\xab\xb9\xc5\x89\xda\x79\x9f\xaf\xd4\x59\xe2\x0f\xe3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xb0\xc3\x8a\x51\x72\x38\xe0\xe1\xca\x17\x0e\x0f\x79\x09\x5a\x45\xc0\xea\x73\x79\xec\xb0\xeb\x7d\x61\x75\x94\xd8\x7d\xc3\x19\x51\xba\x99\x02\x63\xf6\xc5\xbf\x18\x38\x49\x88\x40\xe6\x73\x3a\x44\x76\x03\xfa\x45\x6c\xfd\xb1\x52\x87\xe4\xa2\xb0\x35\x83\x99\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd1\xd3\xbc\x16\x68\xc2\xc7\x9b\xf9\xc6\x34\x4a\xed\x68\x47\xb8\x8a\x55\x58\x4a\xed\x96\x7b\x63\x2e\xdc\xf3\xd6\x3e\x7a\x89\x0a\x51\x5c\x73\x1d\xd6\x04\xc3\x31\xdc\x68\x65\x15\x62\xa8\xca\x43\xcd\x9b\x05\x20\x59\x36\xa9\xaf\x7b\xba\x5b\xe4\x8d\xb2\x87\xc7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0e\x39\x07\xf2\x0e\x8c\x75\x67\x97\xa5\x5e\xcc\xea\x48\x11\xed\x5f\x93\x8e\xa5\xd0\x52\xb8\xa2\x8e\xe2\xd1\x6e\x2d\xf3\xe9\x6b\x2f\x23\x68\xcf\xb3\xe8\xf4\x71\x2b\x9a\xd5\x6f\x96\x3a\x5c\xec\x80\x16\xd2\x57\x9c\xe3\x2f\x44\x1f\x42\x41\xa0\xd4\x7a\xfe\x4d",
                    sizeof(RSArefPrivateKey));
            dumpbuffer("1024 public",(unsigned char*)&publicKey, sizeof(RSArefPublicKey));
            dumpbuffer("1024 private",(unsigned char*)&privateKey, sizeof(RSArefPrivateKey));
        }
        else
        {
             memcpy((unsigned char *)&publicKey,                   "\x00\x08\x00\x00\xc4\x7d\x0e\xf9\x85\x51\x41\x48\x32\xbf\x99\xd0\x61\xd9\x72\x01\x45\xdc\x05\x20\x8e\x6c\x14\x65\x4f\x46\x96\x81\xcf\xa3\x45\x40\x60\x6f\xfb\x88\xcd\x43\xf3\x84\x3d\x78\x74\x70\xf8\xae\xa8\x47\xf8\x3c\x63\xc8\x06\x6c\xd5\xcd\x80\x21\x32\x10\x29\x27\xff\xa7\xdd\xcf\x10\x3c\xcd\x1b\x8b\x39\x84\x12\xf2\xc7\x4c\x71\xc3\x88\xaa\x88\xe2\xfa\x13\xf6\x47\x76\x7b\x1a\xd7\x75\x00\x6d\x8f\x01\xc6\x4e\x05\xeb\xd9\xc6\x0e\xf5\xbd\xf8\xea\x49\x5b\x43\xfa\xa4\x44\xba\x5d\x1a\xc6\x5d\x4d\x5b\xdd\x81\xf2\xeb\xb0\xf1\x91\xc5\x16\x4b\x2b\xfb\x0a\xac\xbd\xd1\xd8\x10\xae\xf1\x46\x84\x00\x64\xfd\x3e\x66\x29\x8a\x06\xc8\x91\x7d\x38\x44\x8d\xe4\x44\xeb\x3b\xb6\x23\xca\x47\x6d\xd8\xbe\x5e\x70\xf4\xad\x78\x88\x0d\xcc\x72\xc4\x11\xa7\xa5\x6f\x8e\x6a\x17\x5f\xbc\xc4\x70\x37\x34\x10\x1f\xd6\x38\xe1\x6b\xb1\x47\x16\x10\x9c\x92\x99\x98\x5b\x69\xf8\xfb\x68\x7e\xe6\x4d\xb7\x8c\x13\xc2\x3d\x3e\x72\xe1\xea\xab\xe8\x78\xdb\x77\x31\x93\x71\x98\x56\x47\x75\x89\xf9\x1a\x4a\xfc\xf1\xd5\x19\x84\x9e\xe4\xc0\x74\x4f\xa4\x25\x60\xd2\x96\xc0\x46\x4b\x43\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11",
                    sizeof(RSArefPublicKey));
             memcpy((unsigned char *)&privateKey,               "\x00\x08\x00\x00\xc4\x7d\x0e\xf9\x85\x51\x41\x48\x32\xbf\x99\xd0\x61\xd9\x72\x01\x45\xdc\x05\x20\x8e\x6c\x14\x65\x4f\x46\x96\x81\xcf\xa3\x45\x40\x60\x6f\xfb\x88\xcd\x43\xf3\x84\x3d\x78\x74\x70\xf8\xae\xa8\x47\xf8\x3c\x63\xc8\x06\x6c\xd5\xcd\x80\x21\x32\x10\x29\x27\xff\xa7\xdd\xcf\x10\x3c\xcd\x1b\x8b\x39\x84\x12\xf2\xc7\x4c\x71\xc3\x88\xaa\x88\xe2\xfa\x13\xf6\x47\x76\x7b\x1a\xd7\x75\x00\x6d\x8f\x01\xc6\x4e\x05\xeb\xd9\xc6\x0e\xf5\xbd\xf8\xea\x49\x5b\x43\xfa\xa4\x44\xba\x5d\x1a\xc6\x5d\x4d\x5b\xdd\x81\xf2\xeb\xb0\xf1\x91\xc5\x16\x4b\x2b\xfb\x0a\xac\xbd\xd1\xd8\x10\xae\xf1\x46\x84\x00\x64\xfd\x3e\x66\x29\x8a\x06\xc8\x91\x7d\x38\x44\x8d\xe4\x44\xeb\x3b\xb6\x23\xca\x47\x6d\xd8\xbe\x5e\x70\xf4\xad\x78\x88\x0d\xcc\x72\xc4\x11\xa7\xa5\x6f\x8e\x6a\x17\x5f\xbc\xc4\x70\x37\x34\x10\x1f\xd6\x38\xe1\x6b\xb1\x47\x16\x10\x9c\x92\x99\x98\x5b\x69\xf8\xfb\x68\x7e\xe6\x4d\xb7\x8c\x13\xc2\x3d\x3e\x72\xe1\xea\xab\xe8\x78\xdb\x77\x31\x93\x71\x98\x56\x47\x75\x89\xf9\x1a\x4a\xfc\xf1\xd5\x19\x84\x9e\xe4\xc0\x74\x4f\xa4\x25\x60\xd2\x96\xc0\x46\x4b\x43\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x00\x68\x05\xf8\xde\x73\xc1\x9b\x08\x1a\xdd\xe8\x04\xe8\x82\x2d\x4b\xf7\xce\xd5\x89\xb4\xcf\xce\x8f\xfc\xcb\x04\x62\xd7\x56\x6f\xf4\xe7\xc2\xd0\x75\x99\xd8\xae\x18\xd5\x3f\xc5\x2c\xbf\xe3\xfe\xbc\xb0\x98\x71\x0f\x8a\xee\x53\x12\x71\x02\x83\xea\x70\x24\x3c\x0d\x93\x8b\xbd\x4d\x5d\x87\x0d\x78\xcd\x73\x71\x78\x91\xe1\xdf\xfd\x0e\xfd\x2c\xde\xbf\x46\x25\xd5\x50\x3b\x63\x01\xb4\xee\xb5\x1f\x0e\xa1\xc6\xe6\x46\x1d\x8f\x73\x0a\x38\x7c\x08\xb7\xd8\xb1\xde\x7e\xbd\x04\x1d\x3b\xd7\x0a\xd6\x48\x17\x9e\xb9\x03\x52\xb6\x94\x95\x8d\xbd\x3e\xb0\x78\x1e\xba\xfd\x85\x47\xd3\xb8\x46\xfa\x85\x2f\x37\x2c\x02\x5d\x31\x77\x5b\x89\x05\xc6\xce\x57\x85\x96\x33\x64\x04\x40\x1e\x3c\x2f\xcf\x99\xbe\xd5\xa8\x52\x6a\x20\xad\x24\xe9\x9f\x72\x9c\x40\x71\x63\xbd\x4d\x6e\x68\x7a\x0a\x06\xe3\xbc\xb5\xd2\x8a\x0b\xa1\xda\x82\x93\x68\x3e\x1c\xbc\x1d\x69\xf9\xf9\x6f\xfe\xad\x81\x5f\x73\xb1\x60\xa4\xc1\xba\x06\x0b\x99\x78\xae\xdc\x76\xc1\x67\xc0\xf6\xc2\x01\x62\x73\xcd\xcc\xa6\x2e\x2b\x87\x32\x67\x45\x12\xb5\x36\xa1\x24\xec\xd5\x9b\x13\x9c\x9b\xcb\xb1\xca\x6f\xfd\xa3\xdc\x11\xb1\xec\x07\xe3\x83\xf3\xe3\x98\x41\xe8\x38\x0a\x25\xb8\x22\x6d\x80\x10\x33\x8c\x7b\xe9\xa1\xea\x24\x37\x91\xf2\x5d\xa5\xb1\xe3\xdf\xdd\xce\x4b\xb0\x4d\xc1\x95\xdf\xfe\x5d\xf4\x35\xd5\xd0\x51\x9a\x12\x01\xb1\x91\xd6\x08\x44\x3a\x6e\x6b\xf2\x19\xee\x76\x43\x91\xd6\x71\xd1\xed\xdb\x94\x78\x05\xf0\x19\xe0\x4d\x81\xfe\x16\x7a\x73\xda\x3c\x19\xac\x2e\x10\x62\x63\xdf\xd7\x90\x16\x3b\xcf\x89\xa4\x67\xc3\xd7\xd1\xa4\x2e\x06\x24\x67\x83\xa4\x28\x49\xa6\x1e\x6a\x4a\x7d\xea\x0e\x22\x0a\x30\x23\xf8\x7a\x1e\x36\x1a\x29\xee\x4b\xb8\x6a\x4d\xfb\xb1\x82\x1e\x2b\xdd\xcc\x09\xc2\x45\xca\x11\xb7\xf1\x84\x6d\x90\x47\xb3\xc7\xbf\x83\xb7\x9e\x2f\xbc\x0c\x56\x5e\x3a\x31\xdb\xab\x8c\x3a\x33\xa0\x73\xf0\x43\xfd\xd0\x2d\xbe\x4a\x76\x73\x89\xb3\xaa\x38\x27\x85\xd9\xf1\xfb\xa0\x25\xbc\x1b\xce\x65\xd9\x91\xe7\xab\xd4\x70\x34\x25\xbd\x89\xf3\xcc\x45\xbc\x09\x9d\x94\x6b\x9c\x18\x79\xa2\x20\x05\xdb\xc2\x63\xe5\xbd\xcf\xf5\xc5\x96\x0e\x54\x50\x77\xb5\xea\x36\x5a\x5b\xd2\x04\x11\xab\x82\x54\x6b\xe0\x0e\x3d\x87\x9a\x61\x6b\x2c\x3a\xfc\x65\x72\xc7\x9b\x13\x3c\x36\xcc\x69\x6e\xb9\x7a\xf0\x7d\xd7\xbb\xd5\xfd\xbc\x44\xcf\xff\x14\x6c\xa1\x03\x7c\x95\xe3\xda\xaa\x0c\x6d\x3c\x67\x75\x6d\x37\x21\x1a\x1b\x31\x3a\x59\x7d\x08\xd1\x34\xf5\xd0\xd9\x18\x97\x7c\x20\x07\xe6\x42\x3d\x0d\x48\x34\xe0\x8d\x4d\xab\x4d\x35\x4b\x51\x05\x74\x3f\x8a\xd5\xf7\x95\x3a\x83\x62\xef\xed\xc8\x5b\x73\x89\x3a\xc4\x90\xdb\x7f\x62\x0d\x17\xc4\xc0\x7a\x04\x76\x0b\xbe\x76\xbd\x8d\x1a\xae\xf4\x31\x63\xfa\x65\xf7\x36\x0c\xa6\xb0\xbe\x06\x6c\xda\x4e\x41\xa1\x03\xe9\xdc\x58\xab\x63\xeb\x3a\xa1\x9e\x82\x2b\x47\x3d\xa7\xa3\xed\x0c\xfc\x45\x6b\x8c\xfa\x6b\x07\x79\xe6\x0c\xc4\x07\x3f\xcb\x0e\x9a\x16\x3a\x87\x47\x93\x24\x1c\x73\x01\xbf\xb0\x83\xfa\x8a\xf1\x5e\x0f\x4f\x0d\x00\x2b\x0d\x73\x42\x4e\x9f\xb8\x27\xbc\x61\x6e\xeb\x3e\x1a\x00\x23\x83\xdd\xef\x6e\xea\xe3\xac\xdd\xf5\x1e\x4f\x32\x94\x45\x9a\x29\xab\x0b\x54\x58\x13\x38\x1a\x71\x63\x6b\x69\x6e\xec\xf3\x30\xd8\x3a\x2d\x23\x8c\xc9\x76\xe5\xf1\x61\x9c\x27\xba\xaf\x65\x7a\x5e\x2e\xbf\x89\xb8\xde\x00\x0d\x67\x16\x36\xf1\x89\xae\x8b\x9f\x43\x20\xea\x77\x55\x9c\x85\xca\x2c\xc9\xc9\x7a\x28\xb4\x7c\xbf\xa7\xcf\xcc\x9d\xd8\xc1\xb7\xde\x47\xc8\x99\x5a\xc9\x47\x5f\x06\xac\xb7\x41\x54\x63\x0d\xa9\x5d\x4b\x2f\xcb\x16\x5a\x5b\xd4\xdd\x9d\x8b\x83\x0a\x08\x04\x00\xe2\xd5\x85\xc7\xd5\x2b\x7d\x5a\x68\x5f\x3d\x3a\x63\xc9\x1a\x59\xe4\x66\xf9\xa5\xd2\xe7\xa9\xf0\x1b\xe6\x83\x4b\xe6\xda\x5f\x58\xb4\x59\x0f\xd0\x37\xa5\x6c\xbc\x8c\xef\xba\xee\xd0\x29\x99\x9c\x84\xbb\xf6\x1f\x37\x13\x2e\xb5\x41\x51\x7a\xfd\xd6\x4c\x52\xd4\x66\x1c\x2a\xf4\x29",
                    sizeof(RSArefPrivateKey));
            //dumpbuffer("2048 public", (unsigned char*)&publicKey, sizeof(RSArefPublicKey));
            //dumpbuffer("2048 private", (unsigned char*)&privateKey, sizeof(RSArefPrivateKey));
        }
#endif


        printf("sfsfsf\n");
        char *s = "\x00\x08\x00\x00\xc4\x7d\x0e\xf9\x85\x51\x41\x48\x32\xbf\x99\xd0\x61\xd9\x72\x01\x45\xdc\x05\x20\x8e\x6c\x14\x65\x4f\x46\x96\x81\xcf\xa3\x45\x40\x60\x6f\xfb\x88\xcd\x43\xf3\x84\x3d\x78\x74\x70\xf8\xae\xa8\x47\xf8\x3c\x63\xc8\x06\x6c\xd5\xcd\x80\x21\x32\x10\x29\x27\xff\xa7\xdd\xcf\x10\x3c\xcd\x1b\x8b\x39\x84\x12\xf2\xc7\x4c\x71\xc3\x88\xaa\x88\xe2\xfa\x13\xf6\x47\x76\x7b\x1a\xd7\x75\x00\x6d\x8f\x01\xc6\x4e\x05\xeb\xd9\xc6\x0e\xf5\xbd\xf8\xea\x49\x5b\x43\xfa\xa4\x44\xba\x5d\x1a\xc6\x5d\x4d\x5b\xdd\x81\xf2\xeb\xb0\xf1\x91\xc5\x16\x4b\x2b\xfb\x0a\xac\xbd\xd1\xd8\x10\xae\xf1\x46\x84\x00\x64\xfd\x3e\x66\x29\x8a\x06\xc8\x91\x7d\x38\x44\x8d\xe4\x44\xeb\x3b\xb6\x23\xca\x47\x6d\xd8\xbe\x5e\x70\xf4\xad\x78\x88\x0d\xcc\x72\xc4\x11\xa7\xa5\x6f\x8e\x6a\x17\x5f\xbc\xc4\x70\x37\x34\x10\x1f\xd6\x38\xe1\x6b\xb1\x47\x16\x10\x9c\x92\x99\x98\x5b\x69\xf8\xfb\x68\x7e\xe6\x4d\xb7\x8c\x13\xc2\x3d\x3e\x72\xe1\xea\xab\xe8\x78\xdb\x77\x31\x93\x71\x98\x56\x47\x75\x89\xf9\x1a\x4a\xfc\xf1\xd5\x19\x84\x9e\xe4\xc0\x74\x4f\xa4\x25\x60\xd2\x96\xc0\x46\x4b\x43\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x00\x68\x05\xf8\xde\x73\xc1\x9b\x08\x1a\xdd\xe8\x04\xe8\x82\x2d\x4b\xf7\xce\xd5\x89\xb4\xcf\xce\x8f\xfc\xcb\x04\x62\xd7\x56\x6f\xf4\xe7\xc2\xd0\x75\x99\xd8\xae\x18\xd5\x3f\xc5\x2c\xbf\xe3\xfe\xbc\xb0\x98\x71\x0f\x8a\xee\x53\x12\x71\x02\x83\xea\x70\x24\x3c\x0d\x93\x8b\xbd\x4d\x5d\x87\x0d\x78\xcd\x73\x71\x78\x91\xe1\xdf\xfd\x0e\xfd\x2c\xde\xbf\x46\x25\xd5\x50\x3b\x63\x01\xb4\xee\xb5\x1f\x0e\xa1\xc6\xe6\x46\x1d\x8f\x73\x0a\x38\x7c\x08\xb7\xd8\xb1\xde\x7e\xbd\x04\x1d\x3b\xd7\x0a\xd6\x48\x17\x9e\xb9\x03\x52\xb6\x94\x95\x8d\xbd\x3e\xb0\x78\x1e\xba\xfd\x85\x47\xd3\xb8\x46\xfa\x85\x2f\x37\x2c\x02\x5d\x31\x77\x5b\x89\x05\xc6\xce\x57\x85\x96\x33\x64\x04\x40\x1e\x3c\x2f\xcf\x99\xbe\xd5\xa8\x52\x6a\x20\xad\x24\xe9\x9f\x72\x9c\x40\x71\x63\xbd\x4d\x6e\x68\x7a\x0a\x06\xe3\xbc\xb5\xd2\x8a\x0b\xa1\xda\x82\x93\x68\x3e\x1c\xbc\x1d\x69\xf9\xf9\x6f\xfe\xad\x81\x5f\x73\xb1\x60\xa4\xc1\xba\x06\x0b\x99\x78\xae\xdc\x76\xc1\x67\xc0\xf6\xc2\x01\x62\x73\xcd\xcc\xa6\x2e\x2b\x87\x32\x67\x45\x12\xb5\x36\xa1\x24\xec\xd5\x9b\x13\x9c\x9b\xcb\xb1\xca\x6f\xfd\xa3\xdc\x11\xb1\xec\x07\xe3\x83\xf3\xe3\x98\x41\xe8\x38\x0a\x25\xb8\x22\x6d\x80\x10\x33\x8c\x7b\xe9\xa1\xea\x24\x37\x91\xf2\x5d\xa5\xb1\xe3\xdf\xdd\xce\x4b\xb0\x4d\xc1\x95\xdf\xfe\x5d\xf4\x35\xd5\xd0\x51\x9a\x12\x01\xb1\x91\xd6\x08\x44\x3a\x6e\x6b\xf2\x19\xee\x76\x43\x91\xd6\x71\xd1\xed\xdb\x94\x78\x05\xf0\x19\xe0\x4d\x81\xfe\x16\x7a\x73\xda\x3c\x19\xac\x2e\x10\x62\x63\xdf\xd7\x90\x16\x3b\xcf\x89\xa4\x67\xc3\xd7\xd1\xa4\x2e\x06\x24\x67\x83\xa4\x28\x49\xa6\x1e\x6a\x4a\x7d\xea\x0e\x22\x0a\x30\x23\xf8\x7a\x1e\x36\x1a\x29\xee\x4b\xb8\x6a\x4d\xfb\xb1\x82\x1e\x2b\xdd\xcc\x09\xc2\x45\xca\x11\xb7\xf1\x84\x6d\x90\x47\xb3\xc7\xbf\x83\xb7\x9e\x2f\xbc\x0c\x56\x5e\x3a\x31\xdb\xab\x8c\x3a\x33\xa0\x73\xf0\x43\xfd\xd0\x2d\xbe\x4a\x76\x73\x89\xb3\xaa\x38\x27\x85\xd9\xf1\xfb\xa0\x25\xbc\x1b\xce\x65\xd9\x91\xe7\xab\xd4\x70\x34\x25\xbd\x89\xf3\xcc\x45\xbc\x09\x9d\x94\x6b\x9c\x18\x79\xa2\x20\x05\xdb\xc2\x63\xe5\xbd\xcf\xf5\xc5\x96\x0e\x54\x50\x77\xb5\xea\x36\x5a\x5b\xd2\x04\x11\xab\x82\x54\x6b\xe0\x0e\x3d\x87\x9a\x61\x6b\x2c\x3a\xfc\x65\x72\xc7\x9b\x13\x3c\x36\xcc\x69\x6e\xb9\x7a\xf0\x7d\xd7\xbb\xd5\xfd\xbc\x44\xcf\xff\x14\x6c\xa1\x03\x7c\x95\xe3\xda\xaa\x0c\x6d\x3c\x67\x75\x6d\x37\x21\x1a\x1b\x31\x3a\x59\x7d\x08\xd1\x34\xf5\xd0\xd9\x18\x97\x7c\x20\x07\xe6\x42\x3d\x0d\x48\x34\xe0\x8d\x4d\xab\x4d\x35\x4b\x51\x05\x74\x3f\x8a\xd5\xf7\x95\x3a\x83\x62\xef\xed\xc8\x5b\x73\x89\x3a\xc4\x90\xdb\x7f\x62\x0d\x17\xc4\xc0\x7a\x04\x76\x0b\xbe\x76\xbd\x8d\x1a\xae\xf4\x31\x63\xfa\x65\xf7\x36\x0c\xa6\xb0\xbe\x06\x6c\xda\x4e\x41\xa1\x03\xe9\xdc\x58\xab\x63\xeb\x3a\xa1\x9e\x82\x2b\x47\x3d\xa7\xa3\xed\x0c\xfc\x45\x6b\x8c\xfa\x6b\x07\x79\xe6\x0c\xc4\x07\x3f\xcb\x0e\x9a\x16\x3a\x87\x47\x93\x24\x1c\x73\x01\xbf\xb0\x83\xfa\x8a\xf1\x5e\x0f\x4f\x0d\x00\x2b\x0d\x73\x42\x4e\x9f\xb8\x27\xbc\x61\x6e\xeb\x3e\x1a\x00\x23\x83\xdd\xef\x6e\xea\xe3\xac\xdd\xf5\x1e\x4f\x32\x94\x45\x9a\x29\xab\x0b\x54\x58\x13\x38\x1a\x71\x63\x6b\x69\x6e\xec\xf3\x30\xd8\x3a\x2d\x23\x8c\xc9\x76\xe5\xf1\x61\x9c\x27\xba\xaf\x65\x7a\x5e\x2e\xbf\x89\xb8\xde\x00\x0d\x67\x16\x36\xf1\x89\xae\x8b\x9f\x43\x20\xea\x77\x55\x9c\x85\xca\x2c\xc9\xc9\x7a\x28\xb4\x7c\xbf\xa7\xcf\xcc\x9d\xd8\xc1\xb7\xde\x47\xc8\x99\x5a\xc9\x47\x5f\x06\xac\xb7\x41\x54\x63\x0d\xa9\x5d\x4b\x2f\xcb\x16\x5a\x5b\xd4\xdd\x9d\x8b\x83\x0a\x08\x04\x00\xe2\xd5\x85\xc7\xd5\x2b\x7d\x5a\x68\x5f\x3d\x3a\x63\xc9\x1a\x59\xe4\x66\xf9\xa5\xd2\xe7\xa9\xf0\x1b\xe6\x83\x4b\xe6\xda\x5f\x58\xb4\x59\x0f\xd0\x37\xa5\x6c\xbc\x8c\xef\xba\xee\xd0\x29\x99\x9c\x84\xbb\xf6\x1f\x37\x13\x2e\xb5\x41\x51\x7a\xfd\xd6\x4c\x52\xd4\x66\x1c\x2a\xf4\x29";
        printf("%d",strlen(s));
        printf("%d",sizeof(RSArefPrivateKey));
        printf("sfsfsf\n");
        pswlen = (unsigned int) strlen(password);
        ret = SDF_GetPrivateKeyAccessRight(hSessionHandle, uiKeyIndex, password, pswlen);
        printf("SDF_GetPrivateKeyAccessRight, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_GetPrivateKeyAccessRight failed\n");
            goto EXIT;
        }
#ifdef SUPPORT_IMPORT_KEY
        ret = SDF_ImportSignPublicKey_RSA(hSessionHandle, uiKeyIndex, &publicKey);
        printf("SDF_ImportSignPublicKey_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ImportSignPublicKey_RSA\n");
            goto EXIT;
        }

        ret = SDF_ImportSignPrivateKey_RSA(hSessionHandle, uiKeyIndex, &privateKey);
        printf("SDF_ImportSignPrivateKey_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ImportSignPrivateKey_RSA\n");
            goto EXIT;
        }

        ret = SDF_ImportEncPublicKey_RSA(hSessionHandle, uiKeyIndex, &publicKey);
        printf("SDF_ImportEncPublicKey_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ImportEncPublicKey_RSA\n");
            goto EXIT;
        }

        ret = SDF_ImportEncPrivateKey_RSA(hSessionHandle, uiKeyIndex, &privateKey);
        printf("SDF_ImportEncPrivateKey_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ImportEncPrivateKey_RSA\n");
            goto EXIT;
        }
#endif

        for (j = 0; j < 256; j++) {
            datain[j] = j;
        }

        //外部公钥加密
        ret = SDF_ExternalPublicKeyOperation_RSA(hSessionHandle, &publicKey, datain, bits / 8, dataout, &outlen);
        printf("SDF_ExternalPublicKeyOperation_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ExternalPublicKeyOperation_RSA\n");
            goto EXIT;
        }

        //外部私钥解密
        ret = SDF_ExternalPrivateKeyOperation_RSA(hSessionHandle, &privateKey, dataout, outlen, verify, &verifylen);
        printf("SDF_ExternalPrivateKeyOperation_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ExternalPrivateKeyOperation_RSA\n");
            goto EXIT;
        }

        if (memcmp(datain, verify, bits / 8)) {
            printf("External Enc Internal Dec failed\n");
            dumpbuffer("cipher", dataout, outlen);
            dumpbuffer("verify", verify, verifylen);
            goto EXIT;
        } else {
            printf("External Enc Internal Dec ok\n");
        }

        ret = SDF_ExternalPublicKeyOperation_RSA(hSessionHandle, &publicKey, verify, verifylen, datain, &outlen);
        printf("SDF_ExternalPublicKeyOperation_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ExternalPublicKeyOperation_RSA\n");
            goto EXIT;
        }


        for (j = 0; j < 256; j++) {
            datain[j] = j;
        }


        //内部公钥加密
        ret = SDF_InternalPublicKeyOperation_RSA(hSessionHandle, uiKeyIndex, datain, bits / 8, dataout, &outlen);
        printf("SDF_InternalPublicKeyOperation_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_InternalPublicKeyOperation_RSA\n");
            goto EXIT;
        }

        //内部私钥解密
        ret = SDF_InternalPrivateKeyOperation_RSA(hSessionHandle, uiKeyIndex, dataout, outlen, verify, &verifylen);
        printf("SDF_InternalPrivateKeyOperation_RSA ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_InternalPrivateKeyOperation_RSA\n");
            goto EXIT;
        }

        if (memcmp(datain, verify, bits / 8)) {
            printf("Internal Enc Internal Dec failed\n");
            dumpbuffer("cipher", dataout, outlen);
            dumpbuffer("verify", verify, verifylen);
            goto EXIT;
        } else {
            printf("Internal Enc Internal Dec ok\n");
        }

        ret = SDF_ReleasePrivateKeyAccessRight(hSessionHandle, uiKeyIndex);
        printf("SDF_ReleasePrivateKeyAccessRight, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_ReleasePrivateKeyAccessRight failed\n");
            goto EXIT;
        }
    }

EXIT:
    return ret;
}


int SM2Test(void *hSessionHandle) {
    int ret = 0;
    unsigned char datain[3072] = {0};
    unsigned char dataout[3072] = {0};
    unsigned char verify[3072] = {0};
    unsigned char dataout2[3072] = {0};
    unsigned int inlen = 0;
    unsigned int outlen = 0;
    unsigned int verifylen = 0;

    unsigned int uiAlgID = 0;
    unsigned int keyIndex = 1;
    char *password = "soft1234";
    unsigned int pswlen = 0;
    ECCrefPublicKey PublicKey;
    ECCrefPublicKey SignPublicKey;
    ECCrefPublicKey EncPublicKey;
    ECCrefPrivateKey PrivateKey;
    unsigned int uiKeyBits = 256;
    ECCSignature signature;
    unsigned int j = 0;

    //产生卡外密钥对
    uiAlgID = SGD_SM2_1;
    ret = SDF_GenerateKeyPair_ECC(hSessionHandle, uiAlgID, uiKeyBits, &PublicKey, &PrivateKey);
    printf("SDF_GenerateKeyPair_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_GenerateKeyPair_ECC failed\n");
        goto EXIT;
    }
#if 1
    memcpy((unsigned char *) &PublicKey,
           "\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe8\x24\xd1\x3b\xc1\xf3\x29\x94\xfb\x73\xca\x0d\x63\x03\xb9\x2a\x94\x21\xe6\x69\xee\xa9\x85\xee\xf1\xa9\x3b\x87\xde\x1f\xb8\x23\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x60\x9e\x3b\x12\xf6\xef\xb7\x9b\x43\x0f\x47\x95\x7d\xfc\xec\x92\x77\x38\x80\x1b\xde\x40\x6f\x1e\xbd\xc3\x15\x8f\xa6\x9f\x1e",
           sizeof(ECCrefPublicKey));
    memcpy((unsigned char *) &PrivateKey,
           "\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x2d\xff\x55\x52\xc2\xe8\x6b\xcc\x0a\xdc\x58\x05\x2c\x5d\xf9\x75\x17\xe2\x4c\x2a\x60\xbb\x05\x7a\x0c\xd1\xd9\xd1\x60\xe2\x5c\x58",
           sizeof(ECCrefPrivateKey));
    //dumpbuffer("public", &PublicKey, sizeof(ECCrefPublicKey));
    //dumpbuffer("private", &PrivateKey, sizeof(ECCrefPrivateKey));
#endif

    dumpbuffer("public", (unsigned char *) &PublicKey, sizeof(ECCrefPublicKey));
    dumpbuffer("private", (unsigned char *) &PrivateKey, sizeof(ECCrefPrivateKey));

#ifdef SUPPORT_IMPORT_KEY
    //导入签名公钥
    ret = SDF_ImportSignPublicKey_ECC(hSessionHandle, keyIndex, &PublicKey);
    printf("SDF_ImportSignPublicKey_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ImportSignPublicKey_ECC failed\n");
        goto EXIT;
    }

    //导入签名私钥
    ret = SDF_ImportSignPrivateKey_ECC(hSessionHandle, keyIndex, &PrivateKey);
    printf("SDF_ImportSignPrivateKey_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ImportSignPrivateKey_ECC failed\n");
        goto EXIT;
    }

    //导入加密公钥
    ret = SDF_ImportEncPublicKey_ECC(hSessionHandle, keyIndex, &PublicKey);
    printf("SDF_ImportEncPublicKey_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ImportEncPublicKey_ECC failed\n");
        goto EXIT;
    }

    //导入加密私钥
    ret = SDF_ImportEncPrivateKey_ECC(hSessionHandle, keyIndex, &PrivateKey);
    printf("SDF_ImportEncPrivateKey_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ImportEncPrivateKey_ECC failed\n");
        goto EXIT;
    }
#endif
    //导出签名公钥
    ret = SDF_ExportSignPublicKey_ECC(hSessionHandle, keyIndex, &SignPublicKey);
    printf("SDF_ExportSignPublicKey_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExportSignPublicKey_ECC failed\n");
        goto EXIT;
    } else {
        if (memcmp(&SignPublicKey, &PublicKey, sizeof(ECCrefPublicKey))) {
            printf("SignPublicKey failed\n");
            goto EXIT;
        } else {
            printf("SignPublicKey Ok\n");
        }
    }

    //导出加密公钥
    memset(&EncPublicKey, 0, sizeof(ECCrefPublicKey));
    ret = SDF_ExportEncPublicKey_ECC(hSessionHandle, keyIndex, &EncPublicKey);
    printf("SDF_ExportEncPublicKey_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExportEncPublicKey_ECC failed\n");
        goto EXIT;
    } else {
        if (memcmp(&EncPublicKey, &PublicKey, sizeof(ECCrefPublicKey))) {
            printf("EncPublicKey failed\n");
            goto EXIT;
        } else {
            printf("EncPublicKey Ok\n");
        }
    }

    //外部公钥加密
    inlen = 2048;
    uiAlgID = SGD_SM2_3;

    ret = SDF_GenerateRandom(hSessionHandle, inlen, datain);
    printf("SDF_GenerateRandom,ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_ExternalEncrypt_ECC(hSessionHandle, uiAlgID, &EncPublicKey, datain, inlen, (ECCCipher *) dataout);
    printf("SDF_ExternalEncrypt_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExternalEncrypt_ECC failed\n");
        goto EXIT;
    }
#if 0
    pswlen = (unsigned int)strlen(password);
    ret = SDF_GetPrivateKeyAccessRight(hSessionHandle, keyIndex, password, pswlen);
    printf("SDF_GetPrivateKeyAccessRight, ret=0x%08x\n", ret);
    if (SDR_OK != ret)
    {
        printf("SDF_GetPrivateKeyAccessRight failed\n");
        goto EXIT;
    }

#endif


    memset(verify, 0, 3072);
    ret = SDF_ExternalDecrypt_ECC(hSessionHandle, uiAlgID, &PrivateKey, (ECCCipher *) dataout, verify, &verifylen);
    printf("SDF_ExternalDecrypt_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExternalDecrypt_ECC failed\n");
        goto EXIT;
    }

    if (memcmp(datain, verify, inlen)) {
        printf("SDF_ExternalDecrypt_ECC verify failed\n");
        goto EXIT;
    }


    ret = SDF_InternalDecrypt_ECC(hSessionHandle, uiAlgID, keyIndex, (ECCCipher *) dataout, verify, &verifylen);
    printf("SDF_InternalDecrypt_ECC default Enc, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_InternalDecrypt_ECC default Enc failed\n");
        goto EXIT;
    }

    if (memcmp(datain, verify, inlen)) {
        printf("SDF_InternalDecrypt_ECC default Enc verify failed\n");
        goto EXIT;
    }

    //信封转换测试
    inlen = 16;
    ret = SDF_ExternalEncrypt_ECC(hSessionHandle, uiAlgID, &EncPublicKey, datain, inlen, (ECCCipher *) dataout);
    printf("SDF_ExternalEncrypt_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExternalEncrypt_ECC failed\n");
        goto EXIT;
    }


    memset(verify, 0, 32);
    ret = SDF_ExternalDecrypt_ECC(hSessionHandle, uiAlgID, &PrivateKey, (ECCCipher *) dataout, verify, &verifylen);
    printf("SDF_ExternalDecrypt_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExternalDecrypt_ECC failed\n");
        goto EXIT;
    }

    if (memcmp(datain, verify, inlen)) {
        printf("SDF_ExternalDecrypt_ECC verify failed\n");
        goto EXIT;
    }

    uiAlgID = SGD_SM2_1;
    inlen = 32;
    for (j = 0; j < 32; j++) {
        datain[j] = j + 1;
    }

    ret = SDF_InternalSign_ECC(hSessionHandle, keyIndex, uiAlgID, datain, inlen, &signature);
    printf("SDF_InternalSign_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_InternalSign_ECC failed\n");
        goto EXIT;
    }

    ret = SDF_InternalVerify_ECC(hSessionHandle, keyIndex, uiAlgID, datain, inlen, &signature);
    printf("SDF_InternalVerify_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_InternalVerify_ECC failed\n");
        goto EXIT;
    }

    //外部公私钥验签
    ret = SDF_ExternalVerify_ECC(hSessionHandle, uiAlgID, &PublicKey, datain, inlen, &signature);
    printf("SDF_ExternalVerify_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExternalVerify_ECC failed\n");
        goto EXIT;
    }

    ret = SDF_ExternalSign_ECC(hSessionHandle, &PrivateKey, datain, inlen, &signature);
    printf("SDF_ExternalSign_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExternalSign_ECC failed\n");
        goto EXIT;
    }

    ret = SDF_InternalVerify_ECC(hSessionHandle, keyIndex, uiAlgID, datain, inlen, &signature);
    printf("SDF_InternalVerify_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_InternalVerify_ECC failed\n");
        goto EXIT;
    }

    ret = SDF_ExternalVerify_ECC(hSessionHandle, uiAlgID, &PublicKey, datain, inlen, &signature);
    printf("SDF_ExternalVerify_ECC, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_ExternalVerify_ECC failed\n");
        goto EXIT;
    }
#if 0
    ret = SDF_ReleasePrivateKeyAccessRight(hSessionHandle, keyIndex);
    printf("SDF_ReleasePrivateKeyAccessRight, ret=0x%08x\n", ret);
    if (SDR_OK != ret)
    {
        printf("SDF_ReleasePrivateKeyAccessRight failed\n");
        goto EXIT;
    }
#endif

EXIT:
    return ret;
}


int SymmticTeset(void *hSessionHandle) {
    int ret = 0;
    int i = 0;
    unsigned char datain[3072] = {0};
    unsigned char dataout[3072] = {0};
    unsigned char verify[3072] = {0};
    unsigned int inlen = 0;
    unsigned int outlen = 0;
    unsigned int verifylen = 0;
    unsigned char result[32] = {0};
    unsigned int uiAlgID = 0;
    unsigned int uiMacAlgID = 0;
    unsigned int keyLen = 16;
    unsigned char key[16] = {0};
    unsigned char iv[16] = {0};
    unsigned char MAC[16] = {0};
    unsigned char *pIV = iv;
    void *keyHandle = NULL;
    int sessionKeyFlag = 0;

    //对称算法卡外密钥加解密测试
    for (i = 0; i < 4; i++) {
        memset(datain, 0x01, 32);
        memset(key, 0x01, 16);
        inlen = 32;

        if (0 == i) {
            printf("test SGD_AES128_ECB:\n");
            uiAlgID = SGD_AES128_ECB;
            memcpy(result, "\x5E\x77\xE5\x9F\x8F\x85\x94\x34\x89\xA2\x41\x49\xC7\x5F\x4E\xC9\x5E\x77\xE5\x9F\x8F\x85\x94\x34\x89\xA2\x41\x49\xC7\x5F\x4E\xC9", 32);
        } else if (1 == i) {
            printf("test SGD_AES128_CBC:\n");
            uiAlgID = SGD_AES128_CBC;
            memset(iv, 0x01, 16);
            memcpy(result, "\xB6\xAE\xAF\xFA\x75\x2D\xC0\x8B\x51\x63\x97\x31\x76\x1A\xED\x00\xFC\x2A\x94\x10\xEA\x0D\x20\x17\xA8\x39\x0F\xCF\x66\xB1\xCF\xA2", 32);
        } else if (2 == i) {
            printf("test SGD_SM4_ECB:\n");
            uiAlgID = SGD_SM4_ECB;
            memcpy(result, "\x18\x5F\x0E\xFD\x0D\xFB\xDB\x1E\xA0\x79\x04\x31\x61\xE3\x94\x99\x18\x5F\x0E\xFD\x0D\xFB\xDB\x1E\xA0\x79\x04\x31\x61\xE3\x94\x99", 32);
        } else if (3 == i) {
            printf("test SGD_SM4_CBC:\n");
            uiAlgID = SGD_SM4_CBC;
            memset(iv, 0x01, 16);
            memcpy(result, "\x82\xF1\xB9\x98\xDE\xBB\xB0\x5E\x06\x36\x92\x43\xFF\x44\x34\x7A\x39\x83\x96\xCE\xFC\x9E\x99\xDC\xBB\x89\x4B\xBB\x35\x2B\xA9\x2C", 32);
        }

        ret = SDF_ExternalEncrypt(hSessionHandle, uiAlgID, key, keyLen, pIV, datain, inlen, dataout, &outlen);
        printf("SDF_ExternalEncrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("encrypt failed\n");
            goto EXIT;
        }

        if (0 != memcmp(dataout, result, 32) || 32 != outlen) {
            printf("correctness failed\n");
            dumpbuffer("result", result, 32);
            dumpbuffer("dataout", dataout, 32);
            goto EXIT;
        } else {
            printf("correctness OK\n");
        }

        memset(iv, 0x01, 16);
        ret = SDF_ExternalDecrypt(hSessionHandle, uiAlgID, key, keyLen, pIV, dataout, outlen, verify, &verifylen);
        printf("SDF_ExternalDecrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            goto EXIT;
        }

        if (0 != memcmp(verify, datain, 32) || 32 != verifylen) {
            printf("decrypt correctness failed\n");
            dumpbuffer("verify", verify, 32);
            dumpbuffer("datain", datain, 32);
            goto EXIT;
        } else {
            printf("decrypt correctness ok\n\n");
        }

        //3k随机数据测试
        inlen = 3072;
        ret = SDF_GenerateRandom(hSessionHandle, inlen, datain);
        printf("SDF_GenerateRandom,ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            goto EXIT;
        }

        memset(iv, 0x01, 16);
        ret = SDF_ExternalEncrypt(hSessionHandle, uiAlgID, key, keyLen, pIV, datain, inlen, dataout, &outlen);
        printf("SDF_ExternalEncrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("encrypt failed\n");
            goto EXIT;
        }

        memset(iv, 0x01, 16);
        ret = SDF_ExternalDecrypt(hSessionHandle, uiAlgID, key, keyLen, pIV, dataout, outlen, verify, &verifylen);
        printf("SDF_ExternalDecrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            goto EXIT;
        }

        if (0 != memcmp(verify, datain, inlen)) {
            printf("decrypt correctness failed\n");
            dumpbuffer("verify", verify, 32);
            dumpbuffer("datain", datain, 32);
            goto EXIT;
        } else {
            printf("decrypt 2k data ok\n\n");
        }
    }

    //对称算法通过密钥索引加解密测试
    ret = SDF_ImportKey(hSessionHandle, key, keyLen, &keyHandle);
    printf("SDF_ImportKey, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    sessionKeyFlag = 1;
    for (i = 0; i < 4; i++) {
        memset(datain, 0x01, 32);
        memset(key, 0x01, 16);
        inlen = 32;

        if (0 == i) {
            printf("test SGD_AES128_ECB:\n");
            uiAlgID = SGD_AES128_ECB;
            memcpy(result, "\x5E\x77\xE5\x9F\x8F\x85\x94\x34\x89\xA2\x41\x49\xC7\x5F\x4E\xC9\x5E\x77\xE5\x9F\x8F\x85\x94\x34\x89\xA2\x41\x49\xC7\x5F\x4E\xC9", 32);
        } else if (1 == i) {
            printf("test SGD_AES128_CBC:\n");
            uiAlgID = SGD_AES128_CBC;
            memset(iv, 0x01, 16);
            memcpy(result, "\xB6\xAE\xAF\xFA\x75\x2D\xC0\x8B\x51\x63\x97\x31\x76\x1A\xED\x00\xFC\x2A\x94\x10\xEA\x0D\x20\x17\xA8\x39\x0F\xCF\x66\xB1\xCF\xA2", 32);
        } else if (2 == i) {
            printf("test SGD_SM4_ECB:\n");
            uiAlgID = SGD_SM4_ECB;
            memcpy(result, "\x18\x5F\x0E\xFD\x0D\xFB\xDB\x1E\xA0\x79\x04\x31\x61\xE3\x94\x99\x18\x5F\x0E\xFD\x0D\xFB\xDB\x1E\xA0\x79\x04\x31\x61\xE3\x94\x99", 32);
        } else if (3 == i) {
            printf("test SGD_SM4_CBC:\n");
            uiAlgID = SGD_SM4_CBC;
            memset(iv, 0x01, 16);
            memcpy(result, "\x82\xF1\xB9\x98\xDE\xBB\xB0\x5E\x06\x36\x92\x43\xFF\x44\x34\x7A\x39\x83\x96\xCE\xFC\x9E\x99\xDC\xBB\x89\x4B\xBB\x35\x2B\xA9\x2C", 32);
        }

        ret = SDF_Encrypt(hSessionHandle, keyHandle, uiAlgID, pIV, datain, inlen, dataout, &outlen);
        printf("SDF_Encrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("encrypt failed\n");
            goto EXIT;
        }

        if (0 != memcmp(dataout, result, 32) || 32 != outlen) {
            printf("correctness failed\n");
            dumpbuffer("dataout", dataout, 32);
            dumpbuffer("result", result, 32);
            goto EXIT;
        } else {
            printf("correctness OK\n");
        }

        memset(iv, 0x01, 16);
        ret = SDF_Decrypt(hSessionHandle, keyHandle, uiAlgID, pIV, dataout, outlen, verify, &verifylen);
        printf("SDF_Decrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            goto EXIT;
        }

        if (0 != memcmp(verify, datain, 32) || 32 != verifylen) {
            printf("decrypt correctness failed\n");
            dumpbuffer("verify", verify, 32);
            dumpbuffer("datain", datain, 32);
            goto EXIT;
        } else {
            printf("decrypt correctness ok\n\n");
        }

        //3k随机数据测试
        inlen = 3072;
        ret = SDF_GenerateRandom(hSessionHandle, inlen, datain);
        printf("SDF_GenerateRandom,ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            goto EXIT;
        }

        memset(iv, 0x01, 16);
        ret = SDF_Encrypt(hSessionHandle, keyHandle, uiAlgID, pIV, datain, inlen, dataout, &outlen);
        printf("SDF_Encrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("encrypt failed\n");
            goto EXIT;
        }

        memset(iv, 0x01, 16);
        ret = SDF_Decrypt(hSessionHandle, keyHandle, uiAlgID, pIV, dataout, outlen, verify, &verifylen);
        printf("SDF_Decrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            goto EXIT;
        }

        if (0 != memcmp(verify, datain, inlen)) {
            printf("decrypt correctness failed\n");
            dumpbuffer("verify", verify, 32);
            dumpbuffer("datain", datain, 32);
            goto EXIT;
        } else {
            printf("decrypt 2k data ok\n\n");
        }
    }

    //MAC计算
    for (i = 0; i < 2; i++) {
        pIV = iv;
        if (0 == i) {
            printf("test SGD_AES128_CBC_MAC:\n");
            uiAlgID = SGD_AES128_CBC;
            uiMacAlgID = SGD_AES128_MAC;
            memset(key, 0x01, 16);
            memset(iv, 0x01, 16);
        } else if (1 == i) {
            printf("test SGD_SM4_CBC_MAC:\n");
            uiAlgID = SGD_SM4_CBC;
            uiMacAlgID = SGD_SM4_MAC;
            memset(key, 0x01, 16);
            memset(iv, 0x01, 16);
        }

        inlen = 32;
        ret = SDF_ExternalEncrypt(hSessionHandle, uiAlgID, key, keyLen, pIV, datain, inlen, dataout, &outlen);
        printf("SDF_ExternalEncrypt, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("encrypt failed\n");
            goto EXIT;
        }

        memcpy(MAC, dataout + outlen - 16, 16);
        memset(iv, 0x01, 16);
        ret = SDF_CalculateMAC(hSessionHandle, keyHandle, uiMacAlgID, pIV, datain, inlen, dataout, &outlen);
        printf("SDF_CalculateMAC, ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("CalculateMAC failed\n");
            goto EXIT;
        }

        if (16 != outlen || 0 != memcmp(MAC, dataout, outlen)) {
            printf("outlen=%d\n", outlen);
            dumpbuffer("MAC", MAC, 16);
            dumpbuffer("dataout", dataout, outlen);
            printf("CalculateMAC failed\n");
        } else {
            printf("CalculateMAC ok\n\n");
        }
    }

EXIT:
    if (1 == sessionKeyFlag) {
        ret = SDF_DestroyKey(hSessionHandle, keyHandle);
        printf("SDF_DestroyKey, ret=0x%08x\n", ret);
    }

    return ret;
}


int SM3Test(void *hSessionHandle) {
    int ret = 0;
    unsigned char datain[3 * 2048] = {0};
    unsigned char hash[32] = {0};
    unsigned int len = 2048;
    unsigned int outlen = 0;
    unsigned char *pHash = "\xF2\x15\x06\x53\x04\x6D\xE9\x4C\x5E\x32\xA3\xE5\x5F\x4B\x6D\x9E\x1D\x54\x88\x92\xEF\x27\x9C\x29\x35\x1B\xEA\xAF\xC0\xE9\x32\x4E";
    ECCrefPublicKey PublicKey;
    unsigned int uiKeyBits = 256;
    unsigned int uiAlgID = 0;

    //1. 单纯SM3测试真确性验证
    memset(datain, 0x01, 32);
    len = 32;
    ret = SDF_HashInit(hSessionHandle, SGD_SM3, NULL, NULL, 0);
    printf("SDF_HashInit, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashUpdate(hSessionHandle, datain, len);
    printf("SDF_HashUpdate ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashFinal(hSessionHandle, hash, &outlen);
    printf("SDF_HashFinal ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = memcmp(hash, pHash, 32);
    if (ret) {
        printf("SDF_Hash  memcmp  faill  ret=%d\n", ret);
    } else {
        printf("SDF_Hash success\n");
    }

    //随机数hash计算
    len = 5000;
    ret = SDF_GenerateRandom(hSessionHandle, len, datain);
    printf("SDF_GenerateRandom,ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        return ret;
    }

    //dumpbuffer("random", datain, len);

    ret = SDF_HashInit(hSessionHandle, SGD_SM3, NULL, NULL, 0);
    printf("SDF_HashInit, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashUpdate(hSessionHandle, datain, len);
    printf("SDF_HashUpdate ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashFinal(hSessionHandle, hash, &outlen);
    printf("SDF_HashFinal  ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    dumpbuffer("hash", hash, 32);

    ret = SDF_HashInit(hSessionHandle, SGD_SM3, NULL, NULL, 0);
    printf("SDF_HashInit, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashUpdate(hSessionHandle, datain, len / 2);
    printf("SDF_HashUpdate ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashUpdate(hSessionHandle, datain + len / 2, len / 2);
    printf("SDF_HashUpdate ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashFinal(hSessionHandle, hash, &outlen);
    printf("SDF_HashFinal  ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    dumpbuffer("hash", hash, 32);


    memcpy((unsigned char *) &PublicKey,
           "\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x4b\xef\x68\x82\x14\xf5\x6a\x7a\xb9\x34\xdd\xe1\xb0\xac\xae\x0c\xd9\x12\xad\x05\x88\xe9\x67\xbc\x4e\x94\xc9\xe8\x57\xe4\x0f\x65\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x38\x44\xf2\xab\x0f\xa9\x5e\x05\xba\xb4\xa7\xa7\x94\x9b\x43\xac\x40\x41\xe1\x83\x0c\x6f\x5e\x9f\x2c\x49\x84\xc4\x80\xe1\x37\x1b",
           sizeof(ECCrefPublicKey));

    uiAlgID = SGD_SM3;
    ret = SDF_HashInit(hSessionHandle, uiAlgID, &PublicKey, "1234567812345678", 16);
    printf("SDF_HashInit, ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashUpdate(hSessionHandle, "12345678", 8);
    printf("SDF_HashUpdate ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    ret = SDF_HashFinal(hSessionHandle, hash, &outlen);
    printf("SDF_HashFinal  ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }

    if (memcmp(hash, "\x14\xde\xa0\x43\x87\xf8\xf7\x8e\x2f\xb8\x34\x73\x26\x67\xfe\xe2\xbb\x86\x0d\x06\xd6\x76\x6b\x86\x5d\xb5\xed\x9e\xfa\x81\x22\x89", 32)) {
        dumpbuffer("hash", hash, 32);
        printf("sm2 prehash failed\n");
        goto EXIT;
    } else {
        printf("sm2 prehash OK\n");
    }

EXIT:

    return 0;
}


int FileTest(void *hSessionHandle) {
    int ret = 0;
    char *pFileName = "file_test";
    char fileName[128] = {0};
    unsigned int fileLen = 0x1000;
    unsigned char datain[0x4000] = {0};
    unsigned char dataout[0x4000] = {0};
    unsigned int len = 0x4000;
    int offset = 0;
    unsigned int i, j;
    unsigned int fileNum = 12;

    ret = SDF_GenerateRandom(hSessionHandle, len, datain);
    printf("SDF_GenerateRandom,ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        goto EXIT;
    }
    //memset(datain, 0x01, len);
    for (j = 0; j < fileNum; j++) {
        offset = 0;
        sprintf(fileName, "%s_%d", pFileName, j);
        ret = SDF_CreateFile(hSessionHandle, fileName, (unsigned int) strlen(fileName), fileLen);
        printf("SDF_CreateFile name=%s, ret=0x%08x\n", fileName, ret);
        if (SDR_OK != ret && 0x0100001A != ret) {
            goto EXIT;
        }

        for (i = 1; i <= (fileLen / 1024); i++) {
            ret = SDF_WriteFile(hSessionHandle, fileName, (unsigned int) strlen(fileName), offset, 1024, datain + offset);
            printf("SDF_WriteFile name=%s, ret=0x%08x\n", fileName, ret);
            if (SDR_OK != ret) {
                goto EXIT;
            }

            offset += 1024;
        }

        offset = 0;
        for (i = 1; i <= (fileLen / 512); i++) {
            len = 512;
            ret = SDF_ReadFile(hSessionHandle, fileName, (unsigned int) strlen(fileName), offset, &len, dataout + offset);
            printf("========================SDF_ReadFile name=%s, ret=0x%08x,i=%d\n", fileName, ret, i);
            if (SDR_OK != ret) {
                goto EXIT;
            }

            offset += 512;
        }

        if (memcmp(datain, dataout, fileLen)) {
            printf("WriteReadFile failed\n");
            goto EXIT;
        } else {
            printf("WriteReadFile ok\n");
        }
    }

    for (j = 0; j < fileNum; j++) {
        sprintf(fileName, "%s_%d", pFileName, j);
        ret = SDF_DeleteFile(hSessionHandle, fileName, (unsigned int) strlen(fileName));
        printf("==SDF_DeleteFile  ret=0x%08x fileName=%s\n", ret, fileName);
        if (SDR_OK != ret) {
            goto EXIT;
        }

        ret = SDF_ReadFile(hSessionHandle, fileName, (unsigned int) strlen(fileName), 0, &len, dataout);
        printf("SDF_ReadFile  ret=0x%08x\n", ret);
        if (SDR_OK != ret) {
            printf("SDF_DeleteFile  oK\n");
        } else {
            printf("SDF_DeleteFile  failed\n");
            goto EXIT;
        }
    }

EXIT:

    return 0;
}

int WriteCert() {
    void *hDeviceHandle = NULL;
    DEVICEINFO devInfo;
    void *hSessionHandle = NULL;
    int ret = -1;
    int len = 0;
    char outBuf[2048];
    char softVersion[128] = {0};
    ret = SDF_Init();
    printf("SDF_Init, ret=0x%08x\n", ret);
    ret = SDF_GetSoftVersion(softVersion, &len);
    printf("SoftVersion=%s\n", softVersion);


    ret = SDF_OpenDevice((void **) &hDeviceHandle);
    printf("SDF_OpenDevice, ret=0x%08x\n", ret);
    if (SDR_OK != ret || hDeviceHandle == NULL) {
        printf("SDF_OpenDevice error=%d\n", ret);
        return -1;
    }


    //printf("hfile=%d\n",((SOFT_DEVICE *)hDeviceHandle)->hFile);
    //printf("szFilePath=%s \n",((SOFT_DEVICE *)hDeviceHandle)->szFilePath);

    ret = SDF_OpenSession(hDeviceHandle, &hSessionHandle);
    printf("SDF_OpenSession, hDeviceHandle=%p, ret=0x%08x\n", hSessionHandle, ret);
    if (SDR_OK != ret || hDeviceHandle == NULL) {
        printf("SDF_OpenSession error=%d\n", ret);
        return -1;
    }

    // printf("hSessionHandle hfile=%d\n",((SOFT_DEVICE *)((SDF_SESSIONDEV *)hSessionHandle)->hDeviceHandle)->hFile);
    //  printf("hSessionHandle szFilePath=%s \n",((SOFT_DEVICE *)((SDF_SESSIONDEV *)hSessionHandle)->hDeviceHandle)->szFilePath);

    memset(&devInfo, 0, sizeof(DEVICEINFO));
    memcpy(devInfo.DeviceSerial, "2024040900100001", strlen("2024040900100001"));

    ret = SDF_GetDeviceInfo(hSessionHandle, &devInfo);
    printf("SDF_GetDeviceInfo,ret=0x%08x\n", ret);
    if (SDR_OK != ret) {
        printf("SDF_GetDeviceInfo error=%d\n", ret);
        return -1;
    }
    dumpdata((unsigned char *) &devInfo, 128);

//    len = 128;
//    ret = SDF_GenerateRandom(hSessionHandle, len, outBuf);
//    printf("SDF_GenerateRandom,ret=0x%08x\n", ret);
//    if (SDR_OK != ret) {
//        printf("SDF_GenerateRandom error=%d\n", ret);
//        return -1;
//    }
//
//    dumpdata(outBuf, len);
#if 1
//    ret = SM2Test(hSessionHandle);
//    if (SDR_OK != ret) {
//        printf("SM2Test error=%d\n", ret);
//        return -1;
//    }

    ret = WriteCaCert(hSessionHandle);
    if (SDR_OK != ret) {
        printf("WriteCaCert error=%d\n", ret);
        return -1;
    }

//    ret = SymmticTeset(hSessionHandle);
//    if (SDR_OK != ret) {
//        printf("SymmticTeset error=%d\n", ret);
//        return -1;
//    }
//
//    ret = SM3Test(hSessionHandle);
//    if (SDR_OK != ret) {
//        printf("SM3Test error=%d\n", ret);
//        return -1;
//    }
#endif
//    ret = FileTest(hSessionHandle);
//    if (SDR_OK != ret) {
//        printf("FileTest error=%d\n", ret);
//        return -1;
//    }


    printf("----------------SDF_CloseSession test-----------------\n");
    ret = SDF_CloseSession(hSessionHandle);
    if (SDR_OK != ret) {
        printf("SDF_CloseSession error=%d\n", ret);
        return -1;
    }
    ret = SDF_CloseSession(hSessionHandle);
    if (SDR_OK == ret) {
        printf("SDF_CloseSession error=%d\n", ret);
        return -1;
    }
    printf("----------------SDF_CloseDevice test-----------------\n");
    ret = SDF_CloseDevice(hDeviceHandle);
    if (SDR_OK != ret) {
        printf("SDF_CloseDevice ok=%d\n", ret);
    }
    ret = SDF_CloseDevice(hDeviceHandle);
    if (SDR_OK != ret) {
        printf("SDF_CloseDevice ok=%d\n", ret);
        return 0;
    }
    return 0;
}


int main(int argc, char *argv[]) {
    WriteCert();
    return 0;
}